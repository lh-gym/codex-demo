yelinghan
---
title: "PPO Playground"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 部分比例优势模型（Partial Proportional Odds Model）完整示例

本 R Markdown 根据 **VGAM** 套件对 `vglm()` 的说明，完整演示如何建立、检查并解读一个部分比例优势模型（PPOM）。流程涵盖：

1. **阅读 `vglm()` 核心参数含义**——结合官方文档梳理 `formula`、`family`、`data`、`constraints` 等关键参数的作用。
2. **模拟示例数据**——构造有序响应变量 \(Y\)（等级 1–4）与两个协变量（连续变量 \(X_1\)、分类变量 \(X_2\)）。
3. **使用 `vglm()` 拟合 PPOM**——通过 `cumulative()` 家族设置 `parallel` 约束，只放宽 \(X_1\) 的比例优势假设。
4. **产出模型摘要与约束结构**——检视系数估计与约束矩阵，确认模型与设定一致。
5. **检验比例优势假设**——比较部分比例与完全比例模型的适配度。
6. **绘制拟合概率曲线**——观察 \(X_1\) 变化对各等级概率的影响。

所有关键代码段都加入中文注释，方便对照 `vglm` 文档理解每个参数的作用。

## 1. 了解 vglm 的核心参数

`vglm()` 的调用形式如下：

```r
vglm(formula,
     family = ...,  # 指定 VGAM 家族函数，如 cumulative()
     data = list(), # 数据来源
     weights = NULL,
     subset = NULL,
     na.action,
     etastart = NULL,
     mustart = NULL,
     coefstart = NULL,
     control = vglm.control(...),
     offset = NULL,
     method = "vglm.fit",
     model = FALSE,
     x.arg = TRUE,
     y.arg = TRUE,
     constraints = NULL,
     ...)
```

在本示例中我们重点使用：

- **formula**：描述响应与协变量的关系，右侧的设计矩阵会复制到每个 cutpoint 的线性预测子。
- **family**：选用 `cumulative(link = "logit", parallel = ...)` 构造累积对数胜算模型，借由 `parallel` 参数控制比例优势约束。
- **data**：指定模拟得到的数据框，便于 `vglm()` 自动寻找变量。
- **constraints / parallel**：若需自定义某些协变量在不同 cutpoint 间是否共享系数，可使用 `parallel` 或更底层的 `constraints`。本例选择 `parallel` 语法，在逻辑上等价于提供特定的约束矩阵。
- **x.arg / y.arg**：设为 `TRUE` 保留线性模型矩阵与响应，方便后续检查。

> 补充说明：根据官方说明，`vglm()` 还能透过 `weights`、`subset`、`offset` 等参数进一步调整拟合过程，甚至允许使用 `constraints` 直接传入矩阵。若日后要适配复杂抽样设计，可将抽样权重放入 `weights`。理解这些可选参数有助于解释为何本示例只需最小化设定即可复现部分比例优势模型。

为方便读者快速对照文档，下表总结了本教程真正用到的参数与设置理由：

| 参数 | 本示例取值 | 与文档的对应关系 |
|------|-------------|--------------------|
| `formula` | `Y ~ X1 + X2` | RHS 会复制到每个线性预测子，与说明书中 “RHS 应用于每个线性预测子” 一致 |
| `family` | `cumulative(link = "logit", parallel = TRUE ~ X2)` | 选用 `cumulative()` VGAM 家族函数，靠 `parallel` 设置部分比例约束 |
| `data` | `ppom_data` | 使用数据框让 `vglm()` 自动检索变量，符合 `data` 参数说明 |
| `x.arg` / `y.arg` | `TRUE` | 按文档建议保留模型矩阵与响应，方便后续 `model.matrix()`、`constraints()` 检视 |
| `control` | `默认` | 本例无需额外调参，但若 IRLS 不收敛，可用 `vglm.control()` 微调 |

了解这些参数后再进入实作，有助于把示例与官方文档对应起来。

## 2. 准备环境

```{r packages}
# 加载所需套件 ------------------------------------------------------------
# VGAM 提供 vglm() 与 cumulative() 家族函数
# ggplot2 & tidyr 用于数据整理与绘图
if (!requireNamespace("VGAM", quietly = TRUE)) {
  install.packages("VGAM")
}
if (!requireNamespace("ggplot2", quietly = TRUE)) {
  install.packages("ggplot2")

}
if (!requireNamespace("tidyr", quietly = TRUE)) {
  install.packages("tidyr")
}

library(VGAM)
library(ggplot2)
library(tidyr)
set.seed(1234)  # 固定随机种子，保证结果可复现
```

## 3. 模拟数据

```{r simulate-data}
# 设定样本量 --------------------------------------------------------------
n <- 600

# 生成连续自变量 X1（例如标准化后的测试分数） --------------------------
X1 <- scale(rnorm(n, mean = 0, sd = 1))[, 1]

# 生成分类自变量 X2（3 个类别："A"、"B"、"C"） -------------------------
X2 <- factor(sample(c("A", "B", "C"), size = n, replace = TRUE, prob = c(0.4, 0.35, 0.25)))

# 设置真实参数 -------------------------------------------------------------
# 截距（越大表示越容易落入较低等级），需保证递增以满足有序结构
alpha <- c(-1.2, 0.2, 1.5)

# 连续变量 X1 的系数（允许非比例，随 cutpoint 改变）
beta_X1 <- c(0.9, 0.6, 0.3)

# 分类变量 X2（基准为 "A"，假设满足比例优势，系数不随 cutpoint 变化）
# 正系数表示相较于 A 族群，更倾向取得较高等级
beta_X2 <- list(
  B = 0.6,  # X2 == "B" 的常数效应
  C = 1.0   # X2 == "C" 的常数效应
)

# 根据参数构造累计 logit --------------------------------------------------
# 对每个 cutpoint 计算 P(Y <= k)
eta_mat <- sapply(1:3, function(k) {
  alpha[k] -
    beta_X1[k] * X1 -
    (ifelse(X2 == "B", beta_X2$B, 0) +
       ifelse(X2 == "C", beta_X2$C, 0))  # 分类变量通过模型矩阵引入
})

cum_prob <- plogis(eta_mat)  # 累积概率矩阵（按等级递增）

# 将累计概率转换为每个等级的概率 ------------------------------------------
prob1 <- cum_prob[, 1]
prob2 <- cum_prob[, 2] - cum_prob[, 1]
prob3 <- cum_prob[, 3] - cum_prob[, 2]
prob4 <- 1 - cum_prob[, 3]
prob_mat <- cbind(prob1, prob2, prob3, prob4)

# 避免数值误差带来负值或总和偏离 1 -----------------------------------------
prob_mat <- pmax(prob_mat, .Machine$double.eps)
prob_mat <- prob_mat / rowSums(prob_mat)

# 多项分布抽样得到有序响应 Y（等级 1-4） ----------------------------------
Y <- apply(prob_mat, 1, function(p) sample(1:4, size = 1, prob = p))

# 整理为数据框 -------------------------------------------------------------
ppom_data <- data.frame(
  Y = ordered(Y, levels = 1:4),  # 指定为有序因子，避免 vglm() 提示警告
  X1 = as.numeric(X1),
  X2 = X2
)

# 查看前几笔数据 ---------------------------------------------------------
stopifnot(is.ordered(ppom_data$Y))  # 双重确认响应变量已标记为有序
head(ppom_data)
```

## 4. 拟合部分比例优势模型

```{r fit-ppom}
# 使用 VGAM::vglm() 拟合 ---------------------------------------------------
# cumulative(link = "logit", parallel = TRUE ~ X2)
# 语法说明：parallel 参数可以指定哪些自变量放宽比例优势假设
# parallel = TRUE ~ X2 表示：只有 X2 及截距被约束为比例优势，
# 其余（X1）可在不同 cutpoint 拥有不同斜率，从而构成“部分”比例优势模型
ppom_fit <- vglm(
  Y ~ X1 + X2,
  family = cumulative(
    link = "logit",
    parallel = TRUE ~ X2,  # 根据文档：指定 X2 与截距保持平行（比例优势）
    zero = NULL            # 与 constraints 同时使用时应设为 NULL，此处显式声明
  ),
  data = ppom_data,
  x.arg = TRUE,            # 保留 LM 设计矩阵，便于与文档说明对照
  y.arg = TRUE
)
```

## 5. 模型系数摘要与约束结构

```{r summary}
# 输出模型摘要 -------------------------------------------------------------
# 可以看到 X1 在三个 cutpoint 上的不同系数，而 X2 的两个系数保持相同
summary(ppom_fit)

# 通过 slotNames() 验证对象槽位 --------------------------------------------
# 文档指出 vglm 对象会存储 coefficients、constraints、model、x 等槽位
# 这里列出主要槽位以确认示例与说明一致
slotNames(ppom_fit)

# 透过 constraints() 查看 vglm 使用的约束矩阵 ------------------------
# 输出结果有助于对应文档中 "constraints" 槽位的说明
constraints(ppom_fit)
```

## 6. 检查比例优势假设

```{r test-po}
# 通过比较：
#   (1) 纯比例优势模型（所有自变量 parallel = TRUE）
#   (2) 部分比例优势模型（只放宽 X1）
# 使用似然比检验评估放宽假设是否显著改进拟合 -------------------------
po_fit <- vglm(
  Y ~ X1 + X2,
  family = cumulative(
    link = "logit",
    parallel = TRUE ~ X1 + X2,
    zero = NULL
  ),
  data = ppom_data,
  x.arg = TRUE,
  y.arg = TRUE
)

# VGAM::lrtest 可直接比较两个嵌套模型 -----------------------------------
VGAM::lrtest(po_fit, ppom_fit)
```

## 7. 绘制拟合概率随 X1 变化的曲线

```{r plot, message=FALSE, warning=FALSE}
# 为绘图生成预测数据 ------------------------------------------------------
# 固定 X2 = "A"，让 X1 在其范围内取 100 个等距点
X1_seq <- seq(min(ppom_data$X1), max(ppom_data$X1), length.out = 100)
newdata_plot <- data.frame(
  X1 = X1_seq,
  X2 = factor("A", levels = levels(ppom_data$X2))
)

# 计算每个等级的拟合概率 ---------------------------------------------------
pred_prob <- as.data.frame(predict(ppom_fit, newdata = newdata_plot, type = "response"))
colnames(pred_prob) <- paste0("等级", 1:4)
plot_df <- cbind(newdata_plot, pred_prob)

# 转成长格式，以便 ggplot2 绘制 -------------------------------------------
plot_df_long <- pivot_longer(
  plot_df,
  cols = startsWith("等级"),
  names_to = "等级",
  values_to = "概率"
)

# 绘制概率曲线 -------------------------------------------------------------
ggplot(plot_df_long, aes(x = X1, y = 概率, color = 等级)) +
  geom_line(size = 1) +
  labs(
    title = "部分比例优势模型：拟合概率随 X1 变化",
    subtitle = "X2 固定为类别 A",
    x = "连续自变量 X1",
    y = "拟合概率"
  ) +
  theme_minimal()
```

## 8. 结果解读提示

- `summary()` 输出显示 X1 在不同 cutpoint 上有不同斜率，说明不满足比例优势假设。
- `lrtest()` 的显著性（若 p 值很小）表示部分比例模型相对于纯比例模型有显著改进。
- 概率曲线可以观察到：随着 X1 增加，各等级概率的变化并非简单平移，体现了部分比例的灵活性。

> 至此，我们完成了一个包含数据模拟、模型拟合、假设检验与图形化展示的完整 Partial Proportional Odds Model 示例。
